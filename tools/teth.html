---
layout: toolTemplate
title: Tethers
---
<script>
var tether = {//remember to also update the select list in the HTML
	materials:{
		zylon:[5800000000,1540],
		aramid:[3620000000,1440],
		steel:[2617000000,8000],
		hppe:[2400000000,970],
		mwcnt: [40000000000,1800],
		xxmwcnt: [120000000000,1800]
	}
};
String.prototype.capitalize = function(){
	if(this.length === 0){
		return "";
	};
	return this[0].toUpperCase() + this.slice(1);
};
function calc(){
	var selector = document.getElementsByName("system")[0];//full support of all bodies in planets.json
	var moon = planets[selector.options[selector.selectedIndex].value];//parent object of the tether
	var warnings = "";//message the user about malformed input
	var form = document.getElementById("input").elements;
	var gnum = function(field){//form parser
		return Number(form[field].value);
	};
	var out = function(id,message){//return output to containers
		document.getElementById(id).innerHTML = message;
	};
	var myRound = function(num,digits){
		return Math.floor(num*Math.pow(10,digits))/Math.pow(10,digits);
	};
//construction of tether object
	tether.foot = gnum("foot")*1000;
	tether.top = gnum("top")*1000;
	tether.centre = gnum("centre")*1000;
	tether.centralMass = gnum("centralMass");
	tether.payload = gnum("payloadMass");
	if(tether.foot < 0){//some checks about malformed input
		warnings  += "The tether foot is inside the Body!<br>";
	};
	if(tether.foot > tether.top){
		warnings  += "The tether foot can not be higher than the top!<br>";
	}
	else if(tether.centre < tether.foot || tether.centre > tether.top){
		warnings += "The centre of the tether must be between the endpoints!<br>";
	};
	tether.time = 2*Math.PI*Math.sqrt(Math.pow(tether.centre + moon.radius,3)/moon.gm);
	tether.centreVel = Math.sqrt(moon.gm/(moon.radius + tether.centre));
	tether.footVel = (tether.foot + moon.radius) * tether.centreVel/(tether.centre + moon.radius);
	tether.topVel = (tether.top + moon.radius) * tether.centreVel/(tether.centre + moon.radius);
	tether.angularVelocity = tether.centreVel/(tether.centre + moon.radius);

	tether.topOrbit = Math.sqrt(moon.gm/(tether.top + moon.radius));
	tether.footOrbit = Math.sqrt(moon.gm/(tether.foot + moon.radius));
	tether.escapeFromTop = Math.sqrt(
		tether.topVel * tether.topVel
		- tether.topOrbit * tether.topOrbit * 2
	);

	tether.hitTheGround = Math.sqrt(
		tether.footVel * tether.footVel
		+ 2*moon.gm / moon.radius
		- tether.footOrbit * tether.footOrbit*2
	);

	tether.newApoapsis = Math.pow(
		(tether.top + moon.radius) * tether.topVel
		,2
	)/(
		2*moon.gm
		- (tether.top + moon.radius) * tether.topVel * tether.topVel
	);


	if(form.overrideMaterial.checked){
		tether.strength = (gnum("tensileStrength")/gnum("safety"))/gnum("density");
	}
	else{
		tether.strength = (tether.materials[form["material"].value][0]/gnum("safety")) / tether.materials[form["material"].value][1];
	};

	tether.lowAcceleration = moon.gm/Math.pow(moon.radius + tether.foot,2) - tether.footVel*tether.footVel/(moon.radius + tether.foot);
	tether.highAcceleration = - moon.gm/Math.pow(moon.radius + tether.top,2) + tether.topVel*tether.topVel/(moon.radius + tether.top);

	//accelertation = mu/r² - r * v_c²/r_c²
	//integral = -mu/r - r²v_c²/(2r_c²)
	//upper part formula = -mu/r_c - v_c²/2 + mu/x + x²v_c²/(2r_c²)
	//upper taper formula = e^((-mu/r_c - v_c²/2 + mu/x + x²v_c²/(2r_c²))/strength)
	//Integral[e^((a+b/x + c*x^2)/d),x]
	// or Integral[e^(a+b/x + c*x^2),x]

	//alternatively:
	//acceleration = mu/r² - w²r
	//integral = -mu/r - w²r²/2

//calculation of taper ratio
	var integral = function(gm,angularVelocity,foot,top){
		return Math.abs(
			(
				-gm/top - angularVelocity*angularVelocity*top*top/2
			) - (
				-gm/foot - angularVelocity*angularVelocity*foot*foot/2
			)
		);
	};

	tether.lowIntegral = integral(
		moon.gm,
		tether.angularVelocity,
		tether.foot + moon.radius,
		tether.centre + moon.radius
	);
	tether.highIntegral = integral(
		moon.gm,
		tether.angularVelocity,
		tether.centre + moon.radius,
		tether.top + moon.radius
	);
	tether.lowRatio = Math.pow(Math.E,tether.lowIntegral/tether.strength);
	tether.highRatio = Math.pow(Math.E,tether.highIntegral/tether.strength);

	var lowIteratorSum = 0;
	var highIteratorSum = 0;
	var iteratorLimit = 1000;
	var lowCrosses = [];
	var highCrosses = [];
//numverical way to find the tether mass. Also used for plotting the width of it
	for(var i=0;i<iteratorLimit;i++){
		var lowCross = Math.pow(
			Math.E,
			integral(moon.gm,tether.angularVelocity,tether.foot + moon.radius,
				tether.foot + i*(tether.centre - tether.foot)/iteratorLimit + moon.radius
			)
			/tether.strength
		);
		lowIteratorSum += lowCross;
		var highCross = Math.pow(
			Math.E,
			integral(moon.gm,tether.angularVelocity,tether.centre + moon.radius,
				tether.centre + i*(tether.top - tether.centre)/iteratorLimit + moon.radius
			)
			/tether.strength
		);
		highIteratorSum += highCross;
		if(i % 10 == 0){
			lowCrosses.push(lowCross);
			highCrosses.push(lowCross);
		};
	};

	tether.lowMass = tether.lowAcceleration*(tether.centre-tether.foot)*(lowIteratorSum/iteratorLimit)/tether.strength;
	tether.highMass = tether.highAcceleration*(tether.top-tether.centre)*(highIteratorSum/iteratorLimit)/tether.strength;

	tether.dockedMomentum = tether.centreVel * tether.centralMass * (moon.radius + tether.centre)
		+ tether.payload * tether.footVel * (moon.radius + tether.foot);

	tether.dockedEnergy = tether.centreVel * tether.centreVel * tether.centralMass/2
		+ tether.footVel*tether.footVel *tether.payload/2
		- tether.payload * moon.gm/(moon.radius + tether.foot)
		- tether.centralMass * moon.gm/(moon.radius + tether.centre);

//parsing of planets.json to find bodies reachable after release from the tether
	var potentialTargets = {
		parent : [],//for the Moon, this is Earth
		siblings : [],//aka other Moons
		aunts : []//for the Moon, this is all the other planets
	};
	if(moon.orbit.hasOwnProperty("parent")){//What about creating variables? Meh, just let the object paths grow :P
		potentialTargets.parent.push(moon.orbit.parent);
		if(planets[moon.orbit.parent].orbit.hasOwnProperty("children")){//find siblings
			for(var i=0;i<planets[moon.orbit.parent].orbit.children.length;i++){
				if(planets[moon.orbit.parent].orbit.children[i] != selector.options[selector.selectedIndex].value){//not select itself
					if(planets[planets[moon.orbit.parent].orbit.children[i]].hasOwnProperty("orbit") && planets[planets[moon.orbit.parent].orbit.children[i]].orbit.hasOwnProperty("semiMajor")){//must have orbital data to be usable
						potentialTargets.siblings.push(planets[moon.orbit.parent].orbit.children[i]);
					};
				};
			};
		};
		if(planets[moon.orbit.parent].orbit.hasOwnProperty("parent") && planets[planets[moon.orbit.parent].orbit.parent].orbit.hasOwnProperty("children")){//find aunts
			for(var i=0;i<planets[planets[moon.orbit.parent].orbit.parent].orbit.children.length;i++){
				if(planets[planets[moon.orbit.parent].orbit.parent].orbit.children[i] != moon.orbit.parent){//not select the parent
					if(planets[planets[planets[moon.orbit.parent].orbit.parent].orbit.children[i]].hasOwnProperty("orbit") && planets[planets[planets[moon.orbit.parent].orbit.parent].orbit.children[i]].orbit.hasOwnProperty("semiMajor")){//must have orbital data to be usable
						potentialTargets.aunts.push(planets[planets[moon.orbit.parent].orbit.parent].orbit.children[i]);
					};
				};
			};
		};
	};
	var targets = [];
	for(var i=0;i<potentialTargets.parent.length;i++){
		targets.push(
			{
				name : potentialTargets.parent[i],
				vinf : moon.orbit.speed - Math.sqrt(
					planets[potentialTargets.parent[i]].gm * (2/(moon.orbit.semiMajor) - 2/(moon.orbit.semiMajor + planets[potentialTargets.parent[i]].radius))
				)
			}
		);
	};
	for(var i=0;i<potentialTargets.siblings.length;i++){
		targets.push(
			{
				name : potentialTargets.siblings[i],
				vinf : Math.abs(moon.orbit.speed - Math.sqrt(
					planets[moon.orbit.parent].gm * (2/(moon.orbit.semiMajor) - 2/(moon.orbit.semiMajor + planets[potentialTargets.siblings[i]].orbit.semiMajor))
				))
			}
		);
	};
	for(var i=0;i<potentialTargets.aunts.length;i++){
		targets.push(
			{
				name : potentialTargets.aunts[i],
				vinf : Math.sqrt(Math.pow(planets[moon.orbit.parent].orbit.speed - Math.sqrt(planets[planets[moon.orbit.parent].orbit.parent].gm * (2/(planets[moon.orbit.parent].orbit.semiMajor) - 2/(planets[moon.orbit.parent].orbit.semiMajor + planets[potentialTargets.aunts[i]].orbit.semiMajor))),2) + moon.orbit.speed*moon.orbit.speed*2) - moon.orbit.speed
			}
		);
	};

	var findRadiusFromVinf = function(vinf,angular){
		var vinf_squared = vinf*vinf;
		var angular_squared = angular*angular;
		var val = moon.radius + tether.centre;
		var step = (moon.radius + tether.centre)/2;
		while(angular_squared*val*val - 2*moon.gm/val < vinf_squared){
			val += step;
			step *= 2;
		};
		for(var i=0;i<50;i++){
			step = step/2;
			if(angular_squared*val*val - 2*moon.gm/val < vinf_squared){
				val += step;
			}
			else{
				val -= step;
			};
		};
		return val;
	};
	while(document.getElementById("releases").hasChildNodes()){
		document.getElementById("releases").removeChild(document.getElementById("releases").lastChild);
	};
	for(var i=0;i<targets.length;i++){
		targets[i].location = findRadiusFromVinf(targets[i].vinf,tether.angularVelocity);
		var item = document.createElement("p");
		item.innerHTML = targets[i].name.capitalize();
		item.innerHTML += " " + myRound((targets[i].location - moon.radius)/1000,2) + "km";
		document.getElementById("releases").appendChild(item);
	};

/*Some math:

(newAltitude + mr) * x * pay + central * (newAltitude + mr + centre - foot) * (newAltitude + mr + centre - foot) * x/(newAltitude + mr)
	= tether.dockedMomentum

x = tether.dockedMomentum/(
		(newAltitude + mr) * pay + central * (newAltitude + mr + centre - foot)²/(newAltitude + mr)
	)

tether.dockedEnergy =
	(
		tether.dockedMomentum/(
			(newAltitude + mr) * pay + central * (newAltitude + mr + centre - foot)²/(newAltitude + mr)
		)
	)² * pay
	+ (
		(newAltitude + mr + centre - foot) * tether.dockedMomentum/(
			(newAltitude + mr) * pay + central * (newAltitude + mr + centre - foot)²/(newAltitude + mr)
		)/(newAltitude + mr)
	)² * central
	- pay * moon.gm/(newAltitude + mr)
	- central * moon.gm/(newAltitude + mr + centre - foot)


*/

	out("lowAcceleration","Acceleration at tether foot: " + myRound(tether.lowAcceleration,5) + " m/s² (" + myRound(100*tether.lowAcceleration/moon.gravity,2) + "% of surface gravity)");
	out("highAcceleration","Acceleration at tether top: " + myRound(tether.highAcceleration,5) + " m/s² (" + myRound(100*tether.highAcceleration/moon.gravity,2) + "% of surface gravity)");
	out("period","Period: " + myRound(tether.time/3600,3) + " hours");
	out("footVel","Tether velocity at foot " + myRound(tether.footVel,3) + " m/s");
	out("centreVel","Tether velocity at centre " + myRound(tether.centreVel,3) + " m/s");
	out("topVel","Tether velocity at top " + myRound(tether.topVel,3) + " m/s");
	if(tether.newApoapsis > 0){
		out("escape","Does not reach escape velocity");
		out("newApoapsis","Apoapsis after release from tether: " + myRound(tether.newApoapsis/1000,3) + " km");
	}
	else{
		out("escape","Vinf after release from tether top " + myRound(tether.escapeFromTop,3) + " m/s (840 m/s is required to reach Earth from the Moon)");
		out("newApoapsis","Apoapsis after release from tether: " + myRound(tether.newApoapsis/1000,3) + " km (negative means escape)");
	};
	out("hitTheGround","&nbsp;&nbsp;Velocity at surface after release from tether foot " + myRound(tether.hitTheGround,3) + " m/s");
	out("lowRatio","foot-centre taper ratio: " + myRound(tether.lowRatio,3));
	out("highRatio","centre-top taper ratio: " + myRound(tether.highRatio,3));
	out("lowMass","Mass of lower tether: "
		+ myRound(tether.lowMass,4)
		+ " x payload mass (payload includes foot platform)");
	out("highMass","Mass of higher tether: "
		+ myRound(tether.highMass,4)
		+ " x payload mass (payload includes top platform)");
	out("lowClimber","Lower tether climber energy usage: " + myRound(tether.lowIntegral,0) + " J/kg");
	out("highClimber","Upper tether climber energy usage: " + myRound(tether.highIntegral,0) + " J/kg");

	out("warnings",warnings);
	var svgNS = "http://www.w3.org/2000/svg";
	var illustration = document.getElementById("svg_ilu");
	while(illustration.lastChild){
    	illustration.removeChild(illustration.lastChild);
	};
	illustration.setAttributeNS(null,"viewBox",Math.max(-moon.radius/900,(moon.radius - (tether.top + tether.foot)/2)/1000) + " " + Math.max(-moon.radius/900,-(tether.top - tether.foot)/4000) + " " + Math.min((moon.radius + tether.top)/850,(tether.top - tether.foot)/450) + " " + Math.min(moon.radius/450,(tether.top - tether.foot)/2000));


//lots of svg drawing:
	var addText = function(container,content,x,y,size,color){
		var newMarker = document.createElementNS(svgNS,"text");
		newMarker.setAttributeNS(null,"x",x);
		newMarker.setAttributeNS(null,"y",y);
		newMarker.setAttributeNS(null,"font-size",size);
		newMarker.setAttributeNS(null,"fill",color);

		var textNode = document.createTextNode(content);
		newMarker.appendChild(textNode);
		container.appendChild(newMarker);
	};
	var addToolTip = function(container,content){
		var newToolTip = document.createElementNS(svgNS,"title");
		var textNode = document.createTextNode(content);
		newToolTip.appendChild(textNode);
		container.appendChild(newToolTip);
	};
	var svg_planet = document.createElementNS(svgNS,"circle");
	svg_planet.setAttributeNS(null,"cx",0);
	svg_planet.setAttributeNS(null,"cy",0);
	if(moon.hasOwnProperty("color")){
		svg_planet.setAttributeNS(null,"fill",moon.color);
	}
	else{
		svg_planet.setAttributeNS(null,"fill","grey");
	};
	svg_planet.setAttributeNS(null,"r",moon.radius/1000);

	addToolTip(svg_planet,selector.options[selector.selectedIndex].value.capitalize());

	var svg_tether = document.createElementNS(svgNS,"line");
	svg_tether.setAttributeNS(null,"x1",(moon.radius + tether.foot)/1000);
	svg_tether.setAttributeNS(null,"y1",0);
	svg_tether.setAttributeNS(null,"x2",(moon.radius + tether.top)/1000);
	svg_tether.setAttributeNS(null,"y2",0);
	svg_tether.setAttributeNS(null,"stroke","black");
	svg_tether.setAttributeNS(null,"stroke-linecap","butt");
	svg_tether.setAttributeNS(null,"stroke-width",(tether.top - tether.foot)/100000);

	var svg_rotate = document.createElementNS(svgNS,"animate");
	svg_rotate.setAttributeNS(null,"attributeName","viewBox");
	svg_rotate.setAttributeNS(null,"begin","indefinite");
	svg_rotate.setAttributeNS(null,"from",-moon.radius/900 + " " + (-moon.radius/900) + " " + (moon.radius*2 + tether.top)/225 + " " + moon.radius/112);
	svg_rotate.setAttributeNS(null,"to",Math.max(-moon.radius/900,(moon.radius - (tether.top + tether.foot)/2)/1000) + " " + Math.max(-moon.radius/900,-(tether.top - tether.foot)/4000) + " " + Math.min((moon.radius + tether.top)/850,(tether.top - tether.foot)/450) + " " + Math.min(moon.radius/450,(tether.top - tether.foot)/2000));
	svg_rotate.setAttributeNS(null,"dur",0.5);

	var marker_container = document.createElementNS(svgNS,"g");
	var text_marker_container = document.createElementNS(svgNS,"g");

    var animation = document.createElementNS(svgNS,"animate");
    animation.setAttributeNS(null,"attributeName","opacity");
    animation.setAttributeNS(null,"begin","indefinite");
    animation.setAttributeNS(null,"values","0;0;1");
    animation.setAttributeNS(null,"dur", 1.5);
    animation.setAttributeNS(null,"fill","freeze");

    var marker_animation = document.createElementNS(svgNS,"animate");
    marker_animation.setAttributeNS(null,"attributeName","opacity");
    marker_animation.setAttributeNS(null,"begin","indefinite");
    marker_animation.setAttributeNS(null,"values","0;0;0;0;1");
    marker_animation.setAttributeNS(null,"dur", 2);
    marker_animation.setAttributeNS(null,"fill","freeze");

    var text_marker_animation = document.createElementNS(svgNS,"animate");
    text_marker_animation.setAttributeNS(null,"attributeName","opacity");
    text_marker_animation.setAttributeNS(null,"begin","indefinite");
    text_marker_animation.setAttributeNS(null,"values","0;0;0;0;0;1");
    text_marker_animation.setAttributeNS(null,"dur", 3);
    text_marker_animation.setAttributeNS(null,"fill","freeze");

	var foot_marker = document.createElementNS(svgNS,"circle");
	foot_marker.setAttributeNS(null,"cx",(tether.foot + moon.radius)/1000);
	foot_marker.setAttributeNS(null,"cy",0);
	foot_marker.setAttributeNS(null,"fill","red");
	foot_marker.setAttributeNS(null,"r",(tether.top - tether.foot)/90000);

	addText(
		text_marker_container,
		"Foot",
		(tether.foot + moon.radius)/1000,
		(tether.top - tether.foot)/30000,
		(tether.top - tether.foot)/40000,
		"black"
	);
	addText(
		text_marker_container,
		"Top",
		(tether.top + moon.radius)/1000,
		(tether.top - tether.foot)/30000,
		(tether.top - tether.foot)/40000,
		"black"
	);
	addText(
		text_marker_container,
		"Anchor",
		(tether.centre + moon.radius)/1000,
		(tether.top - tether.foot)/30000,
		(tether.top - tether.foot)/40000,
		"black"
	);

	var anchor_marker = document.createElementNS(svgNS,"circle");
	anchor_marker.setAttributeNS(null,"cx",(tether.centre + moon.radius)/1000);
	anchor_marker.setAttributeNS(null,"cy",0);
	anchor_marker.setAttributeNS(null,"fill","red");
	anchor_marker.setAttributeNS(null,"r",(tether.top - tether.foot)/90000);

	var top_marker = document.createElementNS(svgNS,"circle");
	top_marker.setAttributeNS(null,"cx",(tether.top + moon.radius)/1000);
	top_marker.setAttributeNS(null,"cy",0);
	top_marker.setAttributeNS(null,"fill","red");
	top_marker.setAttributeNS(null,"r",(tether.top - tether.foot)/90000);

	svg_tether.appendChild(animation);
	illustration.appendChild(svg_planet);
	illustration.appendChild(svg_tether);
	illustration.appendChild(svg_rotate);
	marker_container.appendChild(foot_marker);
	marker_container.appendChild(anchor_marker);
	marker_container.appendChild(top_marker);

	text_marker_container.appendChild(text_marker_animation);
	for(var i=0;i<targets.length;i++){
		var marker = document.createElementNS(svgNS,"circle");
		marker.setAttributeNS(null,"cx",targets[i].location/1000);
		marker.setAttributeNS(null,"cy",0);
		marker.setAttributeNS(null,"fill","blue");
		marker.setAttributeNS(null,"r",(tether.top - tether.foot)/100000);
		addToolTip(marker,"Release point for " + targets[i].name.capitalize() + " transfer\nAltitude " + myRound((targets[i].location - moon.radius)/1000,2) + "km\nVinf " + myRound(targets[i].vinf,2) + "m/s");

		marker_container.appendChild(marker);

		addText(
			text_marker_container,
			targets[i].name.capitalize(),
			targets[i].location/1000,
			(tether.top - tether.foot)/30000,
			(tether.top - tether.foot)/40000,
			"blue"
		);
	};
	//construct path
	var lowerPath = "M"+(tether.foot + moon.radius)/1000 + " " + (tether.top - tether.foot)/20000 + "l" + (tether.centre - tether.foot)/1000 + " 0l0 " + (tether.top - tether.foot)/20000;
	var upperPath = "M"+(tether.top + moon.radius)/1000 +  " " + (tether.top - tether.foot)/20000 + "l" + (tether.centre - tether.top)/1000 + " 0l0 " + (tether.top - tether.foot)/20000;
	for(var i=1;i<lowCrosses.length;i++){
		lowerPath += "l-" + (tether.centre - tether.foot)/(1000*lowCrosses.length) + " " + (Math.sqrt(1/lowCrosses[i]) -  Math.sqrt(1/lowCrosses[i-1]))*(tether.top - tether.foot)/20000;
		upperPath += "l" + (tether.top - tether.centre)/(1000*highCrosses.length) + " " + (Math.sqrt(1/highCrosses[i]) -  Math.sqrt(1/highCrosses[i-1]))*(tether.top - tether.foot)/20000;
	};
	lowerPath += "l-" + (tether.centre - tether.foot)/(1000*lowCrosses.length) + " 0z";
	upperPath += "l" + (tether.top - tether.centre)/(1000*highCrosses.length) + " 0z";
	var tether_cross_low = document.createElementNS(svgNS,"path");
	tether_cross_low.setAttributeNS(null,"fill","black");
	tether_cross_low.setAttributeNS(null,"d",lowerPath);
	tether_cross_low.setAttributeNS(null,"stroke","none");
	text_marker_container.appendChild(tether_cross_low);
	var tether_cross_high = document.createElementNS(svgNS,"path");
	tether_cross_high.setAttributeNS(null,"fill","black");
	tether_cross_high.setAttributeNS(null,"d",upperPath);
	tether_cross_high.setAttributeNS(null,"stroke","none");
	text_marker_container.appendChild(tether_cross_high);

	marker_container.appendChild(marker_animation);
	illustration.appendChild(marker_container);
	illustration.appendChild(text_marker_container);
	svg_rotate.beginElement();
	animation.beginElement();
	marker_animation.beginElement();
	text_marker_animation.beginElement();
	//var illustrationNode = document.getElementById("tetherSketch");
	/*while(illustrationNode.firstChild){
		illustrationNode.removeChild(illustrationNode.firstChild);
	};*/
};
</script>
			<h1>Tethers</h1>
			System<select name="system"></select><br><!--dynamically added-->
			<h3>Vertical tether</h3>
			<form id="input">
				<input name="foot" value="50">Tether foot altitude (km)<br>
				<input name="top" value="9500">Tether top altitude (km)<br>
				<input name="centre" value="5000">Tether centre altitude (km). The part of the tether in circular orbit<br>
				<div class="container">
					Tether material<select name="material">
						<option value="zylon">Zylon (5.8 GPa, 1.54 g/cm<sup>3</sup>)</option>
						<option value="aramid">Aramid (3.62 GPa, 1.44 g/cm<sup>3</sup>)</option>
						<option value="hppe">HPPE (2.4 GPa, 0.97 g/cm<sup>3</sup>)</option>
						<option value="steel">Steel (2.62 GPa, 8 g/cm<sup>3</sup>)</option>
						<option value="mwcnt">Future Carbon Nanotubes (40 GPa, 1.8 g/cm<sup>3</sup>)</option>
						<option value="xxmwcnt">Super-Future Carbon Nanotubes (120 GPa, 1.8 g/cm<sup>3</sup>)</option>
					</select><br>
					<input name="overrideMaterial" type="checkbox">Use custom material instead<br>
					<input name="tensileStrength">Tensile strength (Pa)<br>
					<input name="density">Density kg/m³<br>
					<input name="safety" value="1">Safety factor<br>
				</div>
				<div class="container">
					<input name="centralMass">Central mass<br>
					<input name="payloadMass">Mass of docking shuttle<br>
				</div>
				<p style="color:red;" id="warnings"></p>
			</form>
			<button onclick="calc()">Calculate</button>
			<div id="output">
				<div class="container" id="tetherSketch">
					<svg width="900" height="250" id="svg_ilu"></svg>
				</div><br>
				<div class="container">
					<h4>General information</h4>
					<p id="period"></p>
					<p id="footVel"></p>
					<p id="hitTheGround"></p>
					<p id="centreVel"></p>
					<p id="topVel"></p>
				</div><br>
				<div class="container">
					<h4>If released from top:</h4>
					<p id="escape"></p>
					<p id="newApoapsis"></p>
					<h4>Minimum release altitude:</h4>
					<p id="releases"></p>
				</div><br>
				<div class="container">
					<h4>Climber:</h4>
					<p id="lowClimber"></p>
					<p id="highClimber"></p>
				</div><br>
				<div class="container">
					<h4>Tether properties</h4>
					<p id="lowAcceleration"></p>
					<p id="lowRatio"></p>
					<p id="lowMass"></p>
					<p id="highAcceleration"></p>
					<p id="highRatio"></p>
					<p id="highMass"></p>
				</div>
			</div>
<script>
(function(){//planets.js has lots of data, why not make all possible systems available?
	var availableSystems = [];
		//we on
	for(var planet in planets){//all keys, not only bodies
		if(planets[planet].hasOwnProperty("orbit") && planets[planet].orbit.hasOwnProperty("semiMajor")){//only those with orbital data
			if(planets[planet].hasOwnProperty("radius")){
				if(!planets[planet].hasOwnProperty("gm")){
					if(planets[planet].hasOwnProperty("mass")){
						planets[planet].gm = planets[planet].mass * 6.67408e-11;
					}
					else{
						continue;
					};
				};
				availableSystems.push(planet);
			};
		};
	};
	availableSystems.sort();
	//maka a <select> list out of all the systems
	var systemSelector = document.getElementsByName("system")[0];
	for(var i=0;i<availableSystems.length;i++){
		var opt = document.createElement('option');
		opt.value = availableSystems[i];
		opt.innerHTML = availableSystems[i].capitalize();
		systemSelector.appendChild(opt);
		if(availableSystems[i] == "moon"){//moon should be default
			systemSelector.selectedIndex = i;
		};
	};
})();
</script>
