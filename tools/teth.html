---
layout: toolTemplate
title: Tethers
---
<script>
var tether = {
	materials:{
		zylon:[5800000000,1540],
		aramid:[3620000000,1440],
		steel:[2617000000,8000],
		hppe:[2400000000,970]
	}
};
function calc(){
	var selector = document.getElementsByName("system")[0];
	var moon = planets[selector.options[selector.selectedIndex].value];
	var warnings = "";
	var form = document.getElementById("input").elements;
	var gnum = function(field){
		return Number(form[field].value);
	};
	var out = function(id,message){
		document.getElementById(id).innerHTML = message;
	};
	var myRound = function(num,digits){
		return Math.floor(num*Math.pow(10,digits))/Math.pow(10,digits);
	};
	tether.foot = gnum("foot")*1000;
	tether.top = gnum("top")*1000;
	tether.centre = gnum("centre")*1000;
	tether.centralMass = gnum("centralMass");
	tether.payload = gnum("payloadMass");
	if(tether.foot < 0){
		warnings  += "The tether foot is inside the Body!<br>";
	};
	if(tether.foot > tether.top){
		warnings  += "The tether foot can not be higher than the top!<br>";
	}
	else if(tether.centre < tether.foot || tether.centre > tether.top){
		warnings += "The centre of the tether must be between the endpoints!<br>";
	};
	tether.time = 2*Math.PI*Math.sqrt(Math.pow(tether.centre + moon.radius,3)/moon.gm);
	tether.centreVel = Math.sqrt(moon.gm/(moon.radius + tether.centre));
	tether.footVel = (tether.foot + moon.radius) * tether.centreVel/(tether.centre + moon.radius);
	tether.topVel = (tether.top + moon.radius) * tether.centreVel/(tether.centre + moon.radius);
	tether.angularVelocity = tether.centreVel/(tether.centre + moon.radius);

	tether.topOrbit = Math.sqrt(moon.gm/(tether.top + moon.radius));
	tether.footOrbit = Math.sqrt(moon.gm/(tether.foot + moon.radius));
	tether.escapeFromTop = Math.sqrt(
		tether.topVel * tether.topVel
		- tether.topOrbit * tether.topOrbit * 2
	);

	tether.hitTheGround = Math.sqrt(
		tether.footVel * tether.footVel
		+ 2*moon.gm / moon.radius
		- tether.footOrbit * tether.footOrbit*2
	);

	tether.newApoapsis = Math.pow(
		(tether.top + moon.radius) * tether.topVel
		,2
	)/(
		2*moon.gm
		- (tether.top + moon.radius) * tether.topVel * tether.topVel
	);


	if(form.overrideMaterial.checked){
		tether.strength = (gnum("tensileStrength")/gnum("safety"))/gnum("density");
	}
	else{
		tether.strength = (tether.materials[form["material"].value][0]/gnum("safety")) / tether.materials[form["material"].value][1];
	};

	tether.lowAcceleration = moon.gm/Math.pow(moon.radius + tether.foot,2) - tether.footVel*tether.footVel/(moon.radius + tether.foot);
	tether.highAcceleration = - moon.gm/Math.pow(moon.radius + tether.top,2) + tether.topVel*tether.topVel/(moon.radius + tether.top);

	//accelertation = mu/r² - r * v_c²/r_c²
	//integral = -mu/r - r²v_c²/(2r_c²)
	//upper part formula = -mu/r_c - v_c²/2 + mu/x + x²v_c²/(2r_c²)
	//upper taper formula = e^((-mu/r_c - v_c²/2 + mu/x + x²v_c²/(2r_c²))/strength)
	//Integral[e^((a+b/x + c*x^2)/d),x]
	// or Integral[e^(a+b/x + c*x^2),x]

	//alternatively:
	//acceleration = mu/r² - w²r
	//integral = -mu/r - w²r²/2
	var integral = function(gm,angularVelocity,foot,top){
		return Math.abs(
			(
				-gm/top - angularVelocity*angularVelocity*top*top/2
			) - (
				-gm/foot - angularVelocity*angularVelocity*foot*foot/2
			)
		);
	};

	tether.lowIntegral = integral(moon.gm,tether.angularVelocity,tether.foot + moon.radius,tether.centre + moon.radius);
	tether.highIntegral = integral(moon.gm,tether.angularVelocity,tether.centre + moon.radius,tether.top + moon.radius);
	tether.lowRatio = Math.pow(Math.E,tether.lowIntegral/tether.strength);
	tether.highRatio = Math.pow(Math.E,tether.highIntegral/tether.strength);

	var lowIteratorSum = 0;
	var highIteratorSum = 0;
	var iteratorLimit = 1000;
	for(var i=0;i<iteratorLimit;i++){
		lowIteratorSum += Math.pow(
			Math.E,
			integral(moon.gm,tether.angularVelocity,tether.foot + moon.radius,
				tether.foot + i*(tether.centre - tether.foot)/iteratorLimit + moon.radius
			)
			/tether.strength
		);
		highIteratorSum += Math.pow(
			Math.E,
			integral(moon.gm,tether.angularVelocity,tether.centre + moon.radius,
				tether.centre + i*(tether.top - tether.centre)/iteratorLimit + moon.radius
			)
			/tether.strength
		);
	};

	tether.lowMass = tether.lowAcceleration*(tether.centre-tether.foot)*(lowIteratorSum/iteratorLimit)/tether.strength;
	tether.highMass = tether.highAcceleration*(tether.top-tether.centre)*(highIteratorSum/iteratorLimit)/tether.strength;

	tether.dockedMomentum = tether.centreVel * tether.centralMass * (moon.radius + tether.centre)
		+ tether.payload * tether.footVel * (moon.radius + tether.foot);

	tether.dockedEnergy = tether.centreVel * tether.centreVel * tether.centralMass/2
		+ tether.footVel*tether.footVel *tether.payload/2
		- tether.payload * moon.gm/(moon.radius + tether.foot)
		- tether.centralMass * moon.gm/(moon.radius + tether.centre);
	var potentialTargets = {
		parent : [],
		siblings : [],
		aunts : []
	};
	if(moon.orbit.hasOwnProperty("parent")){//What about creating variables? Meh, just let the object paths grow :P
		potentialTargets.parent.push(moon.orbit.parent);
		if(planets[moon.orbit.parent].orbit.hasOwnProperty("children")){
			for(var i=0;i<planets[moon.orbit.parent].orbit.children.length;i++){
				if(planets[moon.orbit.parent].orbit.children[i] != selector.options[selector.selectedIndex].value){
					if(planets[planets[moon.orbit.parent].orbit.children[i]].hasOwnProperty("orbit") && planets[planets[moon.orbit.parent].orbit.children[i]].orbit.hasOwnProperty("semiMajor")){
						potentialTargets.siblings.push(planets[moon.orbit.parent].orbit.children[i]);
					};
				};
			};
		};
		if(planets[moon.orbit.parent].orbit.hasOwnProperty("parent") && planets[planets[moon.orbit.parent].orbit.parent].orbit.hasOwnProperty("children")){
			for(var i=0;i<planets[planets[moon.orbit.parent].orbit.parent].orbit.children.length;i++){
				if(planets[planets[moon.orbit.parent].orbit.parent].orbit.children[i] != moon.orbit.parent){
					if(planets[planets[planets[moon.orbit.parent].orbit.parent].orbit.children[i]].hasOwnProperty("orbit") && planets[planets[planets[moon.orbit.parent].orbit.parent].orbit.children[i]].orbit.hasOwnProperty("semiMajor")){
						potentialTargets.aunts.push(planets[planets[moon.orbit.parent].orbit.parent].orbit.children[i]);
					};
				};
			};
		};
	};
	var targets = [];
	for(var i=0;i<potentialTargets.parent.length;i++){
		targets.push(
			{
				name : potentialTargets.parent[i],
				vinf : moon.orbit.speed - Math.sqrt(
					planets[potentialTargets.parent[i]].gm * (2/(moon.orbit.semiMajor) - 2/(moon.orbit.semiMajor + planets[potentialTargets.parent[i]].radius))
				)
			}
		);
	};
	for(var i=0;i<potentialTargets.siblings.length;i++){
		targets.push(
			{
				name : potentialTargets.siblings[i],
				vinf : Math.abs(moon.orbit.speed - Math.sqrt(
					planets[moon.orbit.parent].gm * (2/(moon.orbit.semiMajor) - 2/(moon.orbit.semiMajor + planets[potentialTargets.siblings[i]].orbit.semiMajor))
				))
			}
		);
	};
	for(var i=0;i<potentialTargets.aunts.length;i++){
		targets.push(
			{
				name : potentialTargets.aunts[i],
				vinf : Math.sqrt(Math.pow(planets[moon.orbit.parent].orbit.speed - Math.sqrt(planets[planets[moon.orbit.parent].orbit.parent].gm * (2/(planets[moon.orbit.parent].orbit.semiMajor) - 2/(planets[moon.orbit.parent].orbit.semiMajor + planets[potentialTargets.aunts[i]].orbit.semiMajor))),2) + moon.orbit.speed*moon.orbit.speed*2) - moon.orbit.speed
			}
		);
	};

	var findRadiusFromVinf = function(vinf,angular){//autogenerated form wolfram alpha, piped through sed to turn it into js
		var vinf_squared = vinf*vinf;
		var angular_squared = angular*angular;
		var val = moon.radius + tether.centre;
		var step = (moon.radius + tether.centre)/2;
		while(angular_squared*val*val - 2*moon.gm/val < vinf_squared){
			val += step;
			step *= 2;
		};
		for(var i=0;i<50;i++){
			step = step/2;
			if(angular_squared*val*val - 2*moon.gm/val < vinf_squared){
				val += step;
			}
			else{
				val -= step;
			};
		};
		return val;
	};
	while(document.getElementById("releases").hasChildNodes()){
		document.getElementById("releases").removeChild(document.getElementById("releases").lastChild);
	};
	for(var i=0;i<targets.length;i++){
		targets[i].location = findRadiusFromVinf(targets[i].vinf,tether.angularVelocity);
		var item = document.createElement("p");
		item.innerHTML = targets[i].name[0].toUpperCase() + targets[i].name.slice(1);
		item.innerHTML += " " + myRound((targets[i].location - moon.radius)/1000,2) + "km";
		document.getElementById("releases").appendChild(item);
	};

/*Some math:

(newAltitude + mr) * x * pay + central * (newAltitude + mr + centre - foot) * (newAltitude + mr + centre - foot) * x/(newAltitude + mr)
	= tether.dockedMomentum

x = tether.dockedMomentum/(
		(newAltitude + mr) * pay + central * (newAltitude + mr + centre - foot)²/(newAltitude + mr)
	)

tether.dockedEnergy = 
	(
		tether.dockedMomentum/(
			(newAltitude + mr) * pay + central * (newAltitude + mr + centre - foot)²/(newAltitude + mr)
		)
	)² * pay
	+ (
		(newAltitude + mr + centre - foot) * tether.dockedMomentum/(
			(newAltitude + mr) * pay + central * (newAltitude + mr + centre - foot)²/(newAltitude + mr)
		)/(newAltitude + mr)
	)² * central
	- pay * moon.gm/(newAltitude + mr)
	- central * moon.gm/(newAltitude + mr + centre - foot)


*/

	out("lowAcceleration","Acceleration at tether foot: " + myRound(tether.lowAcceleration,5) + " m/s² (" + myRound(100*tether.lowAcceleration/moon.gravity,2) + "% of surface gravity)");
	out("highAcceleration","Acceleration at tether top: " + myRound(tether.highAcceleration,5) + " m/s² (" + myRound(100*tether.highAcceleration/moon.gravity,2) + "% of surface gravity)");
	out("period","Period: " + myRound(tether.time/3600,3) + " hours");
	out("footVel","Tether velocity at foot " + myRound(tether.footVel,3) + " m/s");
	out("centreVel","Tether velocity at centre " + myRound(tether.centreVel,3) + " m/s");
	out("topVel","Tether velocity at top " + myRound(tether.topVel,3) + " m/s");
	if(tether.newApoapsis > 0){
		out("escape","Does not reach escape velocity");
		out("newApoapsis","Apoapsis after release from tether: " + myRound(tether.newApoapsis/1000,3) + " km");
	}
	else{
		out("escape","Vinf after release from tether top " + myRound(tether.escapeFromTop,3) + " m/s (840 m/s is required to reach Earth from the Moon)");
		out("newApoapsis","Apoapsis after release from tether: " + myRound(tether.newApoapsis/1000,3) + " km (negative means escape)");
	};
	out("hitTheGround","&nbsp;&nbsp;Velocity at surface after release from tether foot " + myRound(tether.hitTheGround,3) + " m/s");
	out("lowRatio","foot-centre taper ratio: " + myRound(tether.lowRatio,3));
	out("highRatio","centre-top taper ratio: " + myRound(tether.highRatio,3));
	out("lowMass","Mass of lower tether: "
		+ myRound(tether.lowMass,4)
		+ " x payload mass (payload includes foot platform)");
	out("highMass","Mass of higher tether: "
		+ myRound(tether.highMass,4)
		+ " x payload mass (payload includes top platform)");
	out("lowClimber","Lower tether climber energy usage: " + myRound(tether.lowIntegral,0) + " J/kg");
	out("highClimber","Upper tether climber energy usage: " + myRound(tether.highIntegral,0) + " J/kg");

	out("warnings",warnings);
	var svgNS = "http://www.w3.org/2000/svg";  
	var illustration = document.getElementById("svg_ilu");
	while(illustration.lastChild){
    	illustration.removeChild(illustration.lastChild);
	};
	illustration.setAttributeNS(null,"viewBox",-moon.radius/900 + " " + (-moon.radius/900) + " " + (moon.radius*2 + tether.top)/900 + " " + moon.radius/450);


//lots of svg drawing:
	var svg_planet = document.createElementNS(svgNS,"circle");
	svg_planet.setAttributeNS(null,"cx",0);
	svg_planet.setAttributeNS(null,"cy",0);
	svg_planet.setAttributeNS(null,"fill","grey");
	svg_planet.setAttributeNS(null,"r",moon.radius/1000);

	var svg_tether = document.createElementNS(svgNS,"line");
	svg_tether.setAttributeNS(null,"x1",(moon.radius + tether.foot)/1000);
	svg_tether.setAttributeNS(null,"y1",0);
	svg_tether.setAttributeNS(null,"x2",(moon.radius + tether.top)/1000);
	svg_tether.setAttributeNS(null,"y2",0);
	svg_tether.setAttributeNS(null,"stroke","black");
	svg_tether.setAttributeNS(null,"stroke-linecap","butt");
	svg_tether.setAttributeNS(null,"stroke-width",(tether.top - tether.foot)/100000);

	var svg_rotate = document.createElementNS(svgNS,"animate");
	svg_rotate.setAttributeNS(null,"attributeName","viewBox");
	svg_rotate.setAttributeNS(null,"begin","indefinite");
	svg_rotate.setAttributeNS(null,"from",-moon.radius/900 + " " + (-moon.radius/900) + " " + (moon.radius*2 + tether.top)/225 + " " + moon.radius/112);
	svg_rotate.setAttributeNS(null,"to",-moon.radius/900 + " " + (-moon.radius/900) + " " + (moon.radius*2 + tether.top)/900 + " " + moon.radius/450);
	svg_rotate.setAttributeNS(null,"dur",0.5);

    var animation = document.createElementNS(svgNS,"animate");
    animation.setAttributeNS(null,"attributeName","opacity");
    animation.setAttributeNS(null,"begin","indefinite");
    animation.setAttributeNS(null,"values","0;0;1");
    animation.setAttributeNS(null,"dur", 1.5);
    animation.setAttributeNS(null,"fill","freeze");

    var marker_animation = document.createElementNS(svgNS,"animate");
    marker_animation.setAttributeNS(null,"attributeName","opacity");
    marker_animation.setAttributeNS(null,"begin","indefinite");
    marker_animation.setAttributeNS(null,"values","0;0;0;0;1");
    marker_animation.setAttributeNS(null,"dur", 2);
    marker_animation.setAttributeNS(null,"fill","freeze");

    var text_marker_animation = document.createElementNS(svgNS,"animate");
    text_marker_animation.setAttributeNS(null,"attributeName","opacity");
    text_marker_animation.setAttributeNS(null,"begin","indefinite");
    text_marker_animation.setAttributeNS(null,"values","0;0;0;0;0;1");
    text_marker_animation.setAttributeNS(null,"dur", 3);
    text_marker_animation.setAttributeNS(null,"fill","freeze");

	var foot_marker = document.createElementNS(svgNS,"circle");
	foot_marker.setAttributeNS(null,"cx",(tether.foot + moon.radius)/1000);
	foot_marker.setAttributeNS(null,"cy",0);
	foot_marker.setAttributeNS(null,"fill","red");
	foot_marker.setAttributeNS(null,"r",(tether.top - tether.foot)/90000);

	var foot_marker_text = document.createElementNS(svgNS,"text");
	foot_marker_text.setAttributeNS(null,"x",(tether.foot + moon.radius)/1000);     
	foot_marker_text.setAttributeNS(null,"y",(tether.top - tether.foot)/30000); 
	foot_marker_text.setAttributeNS(null,"font-size",(tether.top - tether.foot)/40000);

	var textNode = document.createTextNode("Foot");
	foot_marker_text.appendChild(textNode);

	var top_marker_text = document.createElementNS(svgNS,"text");
	top_marker_text.setAttributeNS(null,"x",(tether.top+ moon.radius)/1000);     
	top_marker_text.setAttributeNS(null,"y",(tether.top - tether.foot)/30000); 
	top_marker_text.setAttributeNS(null,"font-size",(tether.top - tether.foot)/40000);

	var textNode = document.createTextNode("Top");
	top_marker_text.appendChild(textNode);

	var anchor_marker_text = document.createElementNS(svgNS,"text");
	anchor_marker_text.setAttributeNS(null,"x",(tether.centre+ moon.radius)/1000);     
	anchor_marker_text.setAttributeNS(null,"y",(tether.top - tether.foot)/30000); 
	anchor_marker_text.setAttributeNS(null,"font-size",(tether.top - tether.foot)/40000);

	var textNode = document.createTextNode("Anchor");
	anchor_marker_text.appendChild(textNode);

	var anchor_marker = document.createElementNS(svgNS,"circle");
	anchor_marker.setAttributeNS(null,"cx",(tether.centre + moon.radius)/1000);
	anchor_marker.setAttributeNS(null,"cy",0);
	anchor_marker.setAttributeNS(null,"fill","red");
	anchor_marker.setAttributeNS(null,"r",(tether.top - tether.foot)/90000);

	var top_marker = document.createElementNS(svgNS,"circle");
	top_marker.setAttributeNS(null,"cx",(tether.top + moon.radius)/1000);
	top_marker.setAttributeNS(null,"cy",0);
	top_marker.setAttributeNS(null,"fill","red");
	top_marker.setAttributeNS(null,"r",(tether.top - tether.foot)/90000);
	
	var marker_container = document.createElementNS(svgNS,"g");
	var text_marker_container = document.createElementNS(svgNS,"g");

	svg_tether.appendChild(animation);
	illustration.appendChild(svg_planet);
	illustration.appendChild(svg_tether);
	illustration.appendChild(svg_rotate);
	marker_container.appendChild(foot_marker);
	marker_container.appendChild(anchor_marker);
	marker_container.appendChild(top_marker);

	text_marker_container.appendChild(foot_marker_text);
	text_marker_container.appendChild(anchor_marker_text);
	text_marker_container.appendChild(top_marker_text);
	text_marker_container.appendChild(text_marker_animation);

	marker_container.appendChild(marker_animation);
	illustration.appendChild(marker_container);
	illustration.appendChild(text_marker_container);
	svg_rotate.beginElement();
	animation.beginElement();
	marker_animation.beginElement();
	text_marker_animation.beginElement();
	//var illustrationNode = document.getElementById("tetherSketch");
	/*while(illustrationNode.firstChild){
		illustrationNode.removeChild(illustrationNode.firstChild);
	};*/
};
</script>
			<h1>Tethers</h1>
			System<select name="system"></select><br><!--dynamically added-->
			<h3>Vertical tether</h3>
			<form id="input">
				<input name="foot" value="50">Tether foot altitude (km)<br>
				<input name="top" value="9500">Tether top altitude (km)<br>
				<input name="centre" value="5000">Tether centre altitude (km). The part of the tether in circular orbit<br>
				<div class="container">
					Tether material<select name="material">
						<option value="zylon">Zylon</option>
						<option value="aramid">Aramid</option>
						<option value="hppe">HPPE</option>
						<option value="steel">Steel</option>
					</select><br>
					<input name="overrideMaterial" type="checkbox">Use custom material instead<br>
					<input name="tensileStrength">Tensile strength (Pa)<br>
					<input name="density">Density kg/m³<br>
					<input name="safety" value="1">Safety factor<br>
				</div>
				<div class="container">
					<input name="centralMass">Central mass<br>
					<input name="payloadMass">Mass of docking shuttle<br>
				</div>
				<p style="color:red;" id="warnings"></p>
			</form>
			<button onclick="calc()">Calculate</button>
			<div id="output">
				<div class="container" id="tetherSketch">
					<svg width="800" height="200" id="svg_ilu"></svg>
				</div><br>
				<div class="container">
					<h4>General information</h4>
					<p id="period"></p>
					<p id="footVel"></p>
					<p id="hitTheGround"></p>
					<p id="centreVel"></p>
					<p id="topVel"></p>
				</div><br>
				<div class="container">
					<h4>If released from top:</h4>
					<p id="escape"></p>
					<p id="newApoapsis"></p>
					<h4>Minimum release altitude:</h4>
					<p id="releases"></p>
				</div><br>
				<div class="container">
					<h4>Climber:</h4>
					<p id="lowClimber"></p>
					<p id="highClimber"></p>
				</div><br>
				<div class="container">
					<h4>Tether properties</h4>
					<p id="lowAcceleration"></p>
					<p id="lowRatio"></p>
					<p id="lowMass"></p>
					<p id="highAcceleration"></p>
					<p id="highRatio"></p>
					<p id="highMass"></p>
				</div>
			</div>
<script>
(function(){//planets.js has lots of data, why not make all possible systems available?
	var availableSystems = [];
		//we on
	for(var planet in planets){//all keys, not only bodies
		if(planets[planet].hasOwnProperty("orbit")){//only those with orbital data
			availableSystems.push(planet);
		};
	};
	//maka a <select> list out of all the systems
	var systemSelector = document.getElementsByName("system")[0];
	for(var i=0;i<availableSystems.length;i++){
		var opt = document.createElement('option');
		opt.value = availableSystems[i];
		opt.innerHTML = availableSystems[i][0].toUpperCase() + availableSystems[i].slice(1);
		systemSelector.appendChild(opt);
		if(availableSystems[i] == "moon"){//moon should be default
			systemSelector.selectedIndex = i;
		};
	};
})();
</script>
