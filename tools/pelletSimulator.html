---
layout: toolTemplate
title: Pellet Simulator
---
	</head>
	<body>
		<div class="wrapper" id="main">
			<h1>Pellet simulator</h1>
			<div class="container">
				<p>Finding very sensitive trajectories, like those requiring multiple gravity assists, is a very time consuming trial and error process. This tool allows you to try a whole range of velocities at once to narrow down the trajectory much faster. The idea is neither new nor mine, this is just an implementation.</p>
				<p>This tool is not yet completed</p>
				<form id="controls">
					<input name="physics" type="text" value="200">Physics frames per second<br>
					<input name="simSpeed" type="text" value="50000">Time per second<br>
					<input name="graphics" type="text" value="10">Physics frames per graphic frame<br>
					Origin of coordinate system
					<input name="origin" type="radio" value="earth" checked>Earth
					<input name="origin" type="radio" value="moon" > Moon.<br>
					<input name="radius" type="text" value="400000">Radius (km)<br>
					<input name="argument" type="text" value="20">Argument (degrees)<br>
					<p>Pellet velocity (m/s)</p>
					From: <input name="velocity0" type="text" value="500"> to: <input name="velocity1" type="text" value="600"><br>
					<input name="pellets" type="number" value="400">Number of pellets<br>
					<input name="direction" value="90">Vector direction (degrees)<br>
					View <select name="view">
						<option value="earth">Geocentric</option>
						<option value="moon">Selenocentric</option>
						<option value="normal">Inertial</option>
						<!--<option value="rotating">Co-rotating</option>-->
					</select>
				</form>
				<button onclick="simulator.update()">Update form</button>
				<button onclick="if(simulator.loopID === 0){simulator.unpause()}else{simulator.pause()}" id="pause">Pause</button>
			</div>
			<canvas width="1000" height="1000" id="canvas"></canvas>
		</div>
		<script>
var simulator = {
	init : function(){
		//setup a canvas
		this.canvas = document.getElementById("canvas");
		var ctx = this.canvas.getContext("2d");
		ctx.circle = function(x,y,radius,color){
			var colorBuffer = ctx.fillStyle;
			ctx.beginPath();
			ctx.arc(x,y,radius,0,2*Math.PI);
			ctx.fillStyle = color;
			ctx.fill();
			ctx.fillStyle = colorBuffer;
		};
		this.ctx = ctx;
	},
	physics : {
		params : {},
		state : {},
		step : function(state){
			for(var i=0;i<state.pellets.length;i++){
				state.pellets[i].x += state.pellets[i].vx * this.params.deltaTime;
				state.pellets[i].y += state.pellets[i].vy * this.params.deltaTime;
				//earth gravity:
				var sqHyp = state.pellets[i].x * state.pellets[i].x + state.pellets[i].y * state.pellets[i].y;
				if(Math.sqrt(sqHyp) < planets["earth"].radius + planets["earth"].atmosphere.ceiling){
					state.pellets.splice(i--,1);//collision
					this.params.earth++;
					continue;
				}
				else if(Math.sqrt(sqHyp) > planets["moon"].orbit.semiMajor * 5){
					if(
						state.pellets[i].vx * state.pellets[i].vx + state.pellets[i].vy * state.pellets[i].vy
						> 2 * planets["earth"].gm / (planets["moon"].orbit.semiMajor * 5)
					){
						state.pellets.splice(i--,1);//escape
						this.params.escaped++;
						continue;
					};
				};
				var acceleration = planets["earth"].gm/sqHyp;
				state.pellets[i].vx += acceleration * (-state.pellets[i].x/Math.sqrt(sqHyp)) * this.params.deltaTime;
				state.pellets[i].vy += acceleration * (-state.pellets[i].y/Math.sqrt(sqHyp)) * this.params.deltaTime;
				//moon gravity:
				var relx = state.pellets[i].x
					- planets["moon"].orbit.semiMajor * Math.cos(2*Math.PI*this.params.time/planets["moon"].orbit.period);
				var rely = state.pellets[i].y
					+ planets["moon"].orbit.semiMajor * Math.sin(2*Math.PI*this.params.time/planets["moon"].orbit.period);
				sqHyp = relx * relx + rely * rely;
				if(Math.sqrt(sqHyp) < planets["moon"].radius){
					state.pellets.splice(i--,1);//collision
					this.params.moon++;
					continue;
				};
				var acceleration = planets["moon"].gm/sqHyp;
				state.pellets[i].vx += acceleration * (-relx/Math.sqrt(sqHyp)) * this.params.deltaTime;
				state.pellets[i].vy += acceleration * (-rely/Math.sqrt(sqHyp)) * this.params.deltaTime;
			};
			return state;
		},
	},
	mPerPx : 1000000,
	draw : function(state){
		var canvas = this.canvas;
		var ctx = this.ctx;
		ctx.clearRect(0,0,canvas.width,canvas.height);
		ctx.fillStyle = "black";
		ctx.fillRect(0,0,canvas.width,canvas.height);
		ctx.translate(canvas.width/2,canvas.height/2);

		var moon = planets["moon"];
		var earth = planets["earth"];
		var massRatio = earth.gm / moon.gm;
		moon.x = moon.orbit.semiMajor * Math.cos(2*Math.PI*this.physics.params.time/moon.orbit.period) * massRatio/(massRatio + 1);
		moon.y = -moon.orbit.semiMajor * Math.sin(2*Math.PI*this.physics.params.time/moon.orbit.period) * massRatio/(massRatio + 1);
		earth.x = -moon.x/massRatio;
		earth.y = -moon.y/massRatio;


		//the following is the definition of transform functions for the different views.
		if(this.physics.params.view == "normal"){
			var x = function(ox){
				return ox;
			};
			var y = function(oy){
				return oy;
			};
		}
		else if(this.physics.params.view == "earth"){
			var x = function(ox){
				return ox - earth.x;
			};
			var y = function(oy){
				return oy - earth.y;
			};
		}
		else if(this.physics.params.view == "moon"){
			var x = function(ox){
				return ox - moon.x;
			};
			var y = function(oy){
				return oy - moon.y;
			};
		};


		ctx.circle(
			x(moon.x) / this.mPerPx,
			y(moon.y) / this.mPerPx,
			moon.radius/this.mPerPx,"grey");//moon
		ctx.circle(
			x(earth.x) / this.mPerPx,
			y(earth.y) / this.mPerPx,
			earth.radius/this.mPerPx,"blue");//earth

		var pellets = this.physics.state.pellets;
		for(var i=0;i<pellets.length;i++){
			ctx.circle(x(pellets[i].x)/this.mPerPx,y(pellets[i].y)/this.mPerPx,3,pellets[i].color);
		};
		ctx.translate(-this.canvas.width/2,-this.canvas.height/2);
		ctx.fillStyle = "white";
		ctx.fillText("Object count: "+pellets.length,10,15);
		ctx.fillText("Earth collisions: "+this.physics.params.earth,10,30);
		ctx.fillText("Moon collisions: "+this.physics.params.moon,10,45);
		ctx.fillText("Escaped: "+this.physics.params.escaped,10,60);
	},
	update : function(){
		var form = document.getElementById("controls");
		form.find = function(field){
			return Number(this.elements[field].value);
		};
		var rainbowColors = function(index,number){
			if(index < (number-1)/2){
				return "rgb("+(255-index*510/(number-1))+","+(index*510/(number-1))+",0)";
			}
			else if(index == (number-1)/2){
				return "rgb(0,255,0)";
			}
			else{
				return "rgb(0,"+(510-index*510/(number-1))+","+(-255+index*510/(number-1))+")";
			};
		};

		var params = {
			fps       : Math.floor(
				form.find("graphics") * 1000 / form.find("physics")
			),
			deltaTime : (Math.floor(
				form.find("graphics") * 1000 / form.find("physics")
			)/1000) * form.find("simSpeed") / form.find("graphics"),
			simSpeed  : form.find("simSpeed"),
			graphics  : form.find("graphics"),
			velocity0 : form.find("velocity0"),
			velocity1 : form.find("velocity1"),
			direction : Math.PI * form.find("direction")/180,
			radius    : form.find("radius")*1000,
			argument  : Math.PI * form.find("argument")/180,
			time      : 0,
			escaped   : 0,
			earth     : 0,
			moon      : 0,
			view      : form.elements.view.options[form.elements.view.selectedIndex].value//just why did they design <select> like this?
		};
		var pellets = [];
		if(form.origin.value === "earth"){
			x = Math.cos(params.argument) * params.radius;
		}
		else{
			x = Math.cos(params.argument) * params.radius + planets["moon"].orbit.semiMajor;
		};
		var y = Math.sin(params.argument) * params.radius;
		for(var i = 0;i < form.find("pellets");i++){
			var velocity = params.velocity0 + (params.velocity1 - params.velocity0) * i/(form.find("pellets")-1);
			var pellet = {
				vx : Math.cos(params.direction + params.argument) * velocity,
				vy : Math.sin(params.direction + params.argument) * velocity,
				y  : y,
				x  : x,
				color : rainbowColors(i,form.find("pellets"))
			};
			pellets.push(pellet);
		};
		this.physics.state.pellets = pellets;
		this.physics.params = params;
		this.loop = function(){
			for(var i=0;i<this.physics.params.graphics;i++){
				this.physics.state = this.physics.step(this.physics.state);
				this.physics.params.time += this.physics.params.deltaTime;
			};
			this.draw(this.physicsState);
		};
		simulator.unpause();
	},
	pause : function(){
		clearInterval(simulator.loopID);
		simulator.loopID = 0;//not used by any browser
		document.getElementById("pause").innerHTML = "Unpause";
	},
	unpause : function(){
		simulator.loopID = setInterval(
			function(){
				simulator.loop()
			},
			this.physics.params.fps
		);
		document.getElementById("pause").innerHTML = "Pause";
	}
};
simulator.init();
		</script>
