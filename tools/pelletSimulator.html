---
layout: toolTemplate
title: Pellet Simulator
---
	</head>
	<body>
		<div class="wrapper" id="main">
			<h1>Pellet simulator</h1>
			<div class="container">
				<p>Finding very sensitive trajectories, like those requiring multiple gravity assists, is a very time consuming trial and error process. This tool allows you to try a whole range of velocities at once to narrow down the trajectory much faster. The idea is neither new nor mine, this is just an implementation.</p>
				<form id="controls">
					<h3>Initial state</h3>
					<p>Requires restart to take effect</p>
					Origin of coordinate system
					<input name="origin" type="radio" value="earth" checked>Earth
					<input name="origin" type="radio" value="moon" > Moon
					<input name="origin" type="radio" value="normal" > Barycentre<br>
					<input name="radius" type="text" value="400000">Radius (km)<br>
					<input name="argument" type="text" value="20">Argument (degrees)<br>
					<p>Pellet velocity (m/s)</p>
					From: <input name="velocity0" type="text" value="600"> to: <input name="velocity1" type="text" value="700"><br>
					<input name="pellets" type="number" value="800">Number of pellets<br>
					<input name="direction" value="90">Vector direction (degrees)<br>
					<h3>View options</h3>
					<p>Adjust to change speed, view, and rendering of current simulation</p>
					<input name="simSpeed" type="text" value="100000" onchange="simulator.change()">Simulation speed<br>
					<input name="physics" type="text" value="200" onchange="simulator.change()">Physics fps<br>
					<input name="graphics" type="text" value="20" onchange="simulator.change()">Graphics fps<br>
					View <select name="view" onchange="simulator.change()">
						<option value="earth">Geocentric</option>
						<option value="moon">Selenocentric</option>
						<option value="normal">Inertial</option>
						<option value="rotating">Co-rotating</option>
					</select>
				</form><br>
				<p>Move around width W,A,S,D zoom with + and -</p>
				<button onclick="simulator.update()">Restart simulation</button>
				<button onclick="simulator.pause()">Pause</button><button onclick="simulator.unpause()">Unpause</button>
			</div>
			<canvas width="1000" height="1000" id="canvas"></canvas>
		</div>
		<script>
var timeFormat = function(seconds){
	seconds = Math.floor(seconds);
	var minutes = Math.floor(seconds / 60);
	seconds -= minutes*60;
	var hours = Math.floor(minutes / 60);
	minutes -= hours*60;
	var days = Math.floor(hours / 24);
	hours -= days*24;
	var years = Math.floor(days / 365);
	days -= years*365;
	var timeString = "";
	var topFlag = false;
	if(years > 0 || topFlag){
		timeString += years + "y ";
		topFlag = true;
	};
	if(days > 0 || topFlag){
		timeString += days + "d ";
		topFlag = true;
	};
	if(hours > 0 || topFlag){
		timeString += hours + "h ";
		topFlag = true;
	};
	if(minutes > 0 || topFlag){
		timeString += minutes + "m ";
		topFlag = true;
	};
	if(seconds > 0 || topFlag){
		timeString += seconds + "s ";
		topFlag = true;
	};
	return timeString;
};
var simulator = {
	init : function(){
		//setup a canvas
		this.canvas = document.getElementById("canvas");
		var ctx = this.canvas.getContext("2d");
		ctx.circle = function(position,radius,color){
			ctx.beginPath();
			ctx.arc(position.x,position.y,radius,0,2*Math.PI);
			ctx.fillStyle = color;
			ctx.fill();
		};
		this.ctx = ctx;
		this.physics.moon = planets["moon"];
		this.physics.earth = planets["earth"];
		this.physics.massRatio = this.physics.earth.gm / this.physics.moon.gm;
	},
	physics : {
		params : {},
		state : {
			pellets : []
		},
		step : function(state){
			var earth = this.earth;
			var moon = this.moon;
			var massRatio = this.massRatio;
			for(var i=0;i<state.pellets.length;i++){
				state.pellets[i].x += state.pellets[i].vx * this.params.deltaTime;
				state.pellets[i].y += state.pellets[i].vy * this.params.deltaTime;
				//earth gravity:
				var relx = state.pellets[i].x
					+ moon.orbit.semiMajor * Math.cos(2*Math.PI*this.params.time/moon.orbit.period) * 1/(massRatio + 1);
				var rely = state.pellets[i].y
					- moon.orbit.semiMajor * Math.sin(2*Math.PI*this.params.time/moon.orbit.period) * 1/(massRatio + 1);
				sqHyp = relx * relx + rely * rely;
				if(Math.sqrt(sqHyp) < planets["earth"].radius + planets["earth"].atmosphere.ceiling){
					state.pellets.splice(i--,1);//collision
					this.params.earth++;
					continue;
				}
				else if(Math.sqrt(sqHyp) > planets["moon"].orbit.semiMajor * 5){
					if(
						state.pellets[i].vx * state.pellets[i].vx + state.pellets[i].vy * state.pellets[i].vy
						> 2 * planets["earth"].gm / (planets["moon"].orbit.semiMajor * 5)
					){
						state.pellets.splice(i--,1);//escape
						this.params.escaped++;
						continue;
					};
				};
				var acceleration = planets["earth"].gm/sqHyp;
				state.pellets[i].vx += acceleration * (-relx/Math.sqrt(sqHyp)) * this.params.deltaTime;
				state.pellets[i].vy += acceleration * (-rely/Math.sqrt(sqHyp)) * this.params.deltaTime;
				//moon gravity:
				var relx = state.pellets[i].x
					- moon.orbit.semiMajor * Math.cos(2*Math.PI*this.params.time/moon.orbit.period) * massRatio/(massRatio + 1);
				var rely = state.pellets[i].y
					+ moon.orbit.semiMajor * Math.sin(2*Math.PI*this.params.time/moon.orbit.period) * massRatio/(massRatio + 1);
				sqHyp = relx * relx + rely * rely;
				if(Math.sqrt(sqHyp) < planets["moon"].radius){
					state.pellets.splice(i--,1);//collision
					this.params.moon++;
					continue;
				};
				var acceleration = planets["moon"].gm/sqHyp;
				state.pellets[i].vx += acceleration * (-relx/Math.sqrt(sqHyp)) * this.params.deltaTime;
				state.pellets[i].vy += acceleration * (-rely/Math.sqrt(sqHyp)) * this.params.deltaTime;
			};
			return state;
		}
	},
	mPerPx : 1000000,
	draw : function(state){
		var moon = this.physics.moon;
		var earth = this.physics.earth;
		var massRatio = this.physics.massRatio;
		var canvas = this.canvas;
		var ctx = this.ctx;
		ctx.clearRect(0,0,canvas.width,canvas.height);
		ctx.fillStyle = "black";
		ctx.fillRect(0,0,canvas.width,canvas.height);
		ctx.translate(canvas.width/2,canvas.height/2);

		moon.x = moon.orbit.semiMajor * Math.cos(2*Math.PI*this.physics.params.time/moon.orbit.period) * massRatio/(massRatio + 1);
		moon.y = -moon.orbit.semiMajor * Math.sin(2*Math.PI*this.physics.params.time/moon.orbit.period) * massRatio/(massRatio + 1);
		earth.x = -moon.x/massRatio;
		earth.y = -moon.y/massRatio;


		//the following is the definition of transform functions for the different views.
		if(this.physics.params.view == "normal"){
			var transform = function(position){
				return {
					x : position.x/simulator.mPerPx + simulator.offsetX,
					y : position.y/simulator.mPerPx + simulator.offsetY
				};
			};
		}
		else if(this.physics.params.view == "earth"){
			var transform = function(position){
				return {
					x : (position.x - earth.x)/simulator.mPerPx + simulator.offsetX,
					y : (position.y - earth.y)/simulator.mPerPx + simulator.offsetY
				};
			};
		}
		else if(this.physics.params.view == "moon"){
			var transform = function(position){
				return {
					x : (position.x - moon.x)/simulator.mPerPx + simulator.offsetX,
					y : (position.y - moon.y)/simulator.mPerPx + simulator.offsetY
				};
			};
		}
		else if(this.physics.params.view == "rotating"){
			var transform = function(position){
				var angle = 2*Math.PI*simulator.physics.params.time/moon.orbit.period;
				return {
					x : (position.x * Math.cos(angle) - position.y * Math.sin(angle))/simulator.mPerPx + simulator.offsetX,
					y : (position.y * Math.cos(angle) + position.x * Math.sin(angle))/simulator.mPerPx + simulator.offsetY
				};
			};
		};


		ctx.circle(
			transform({
				x : moon.x,
				y : moon.y
			}),
			moon.radius/this.mPerPx,"grey");//moon
		ctx.circle(
			transform({
				x : earth.x,
				y : earth.y
			}),
			earth.radius/this.mPerPx,"blue");//earth

		var pellets = this.physics.state.pellets;
		for(var i=0;i<pellets.length;i++){
			ctx.circle(
				transform({
					x : pellets[i].x,
					y : pellets[i].y
				}),
				3,pellets[i].color);
		};
		ctx.translate(-this.canvas.width/2,-this.canvas.height/2);
		ctx.fillStyle = "white";
		ctx.fillText("Time elapsed: "+timeFormat(this.physics.params.time),10,15);
		ctx.fillText("Object count: "+pellets.length,10,30);
		ctx.fillText("Earth collisions: "+this.physics.params.earth,10,45);
		ctx.fillText("Moon collisions: "+this.physics.params.moon,10,60);
		ctx.fillText("Escaped: "+this.physics.params.escaped,10,75);
	},
	update : function(){
		var form = document.getElementById("controls");
		form.find = function(field){
			return Number(this.elements[field].value);
		};
		var rainbowColors = function(index,number){
			if(index < (number-1)/2){
				return "rgb("+Math.floor((255-index*510/(number-1)))+","+Math.floor((index*510/(number-1)))+",0)";
			}
			else if(index == (number-1)/2){
				return "rgb(0,255,0)";
			}
			else{
				return "rgb(0,"+Math.floor((510-index*510/(number-1)))+","+Math.floor((-255+index*510/(number-1)))+")";
			};
		};

		var params = {
			physicsFPS : 1000 / form.find("physics"),
			graphicsFPS : 1000 / form.find("graphics"),
			deltaTime : form.find("simSpeed") / form.find("physics"),
			graphics  : form.find("graphics"),
			velocity0 : form.find("velocity0"),
			velocity1 : form.find("velocity1"),
			direction : Math.PI * form.find("direction")/180,
			radius    : form.find("radius")*1000,
			argument  : Math.PI * form.find("argument")/180,
			time      : 0,
			escaped   : 0,
			earth     : 0,
			moon      : 0,
			view      : form.elements.view.options[form.elements.view.selectedIndex].value//just why did they design <select> like this?
		};
		var pellets = [];
		var moon = planets["moon"];
		var earth = planets["earth"];
		var massRatio = earth.gm / moon.gm;
		var x = Math.cos(params.argument) * params.radius;
		if(form.origin.value === "earth"){
			x -= planets["moon"].orbit.semiMajor * 1/(massRatio + 1);
		}
		else if(form.origin.value === "moon"){
			x += planets["moon"].orbit.semiMajor * massRatio/(massRatio + 1);
		};
		var y = Math.sin(params.argument) * params.radius;
		for(var i = 0;i < form.find("pellets");i++){
			var velocity = params.velocity0 + (params.velocity1 - params.velocity0) * i/(form.find("pellets")-1);
			var pellet = {
				vx : Math.cos(params.direction + params.argument) * velocity,
				vy : Math.sin(params.direction + params.argument) * velocity,
				y  : y,
				x  : x,
				color : rainbowColors(i,form.find("pellets"))
			};
			pellets.push(pellet);
		};
		this.physics.state.pellets = pellets;
		this.physics.params = params;
		this.physicsLoop = function(){
			this.physics.state = this.physics.step(this.physics.state);
			this.physics.params.time += this.physics.params.deltaTime;
		};
		this.graphicsLoop = function(){
			this.draw(this.physics.State);
		};
		physicsLoopID = setInterval(
			function(){
				simulator.physicsLoop();
			},this.physics.params.physicsFPS
		);
		graphicsLoopID = setInterval(
			function(){
				simulator.graphicsLoop();
			},this.physics.params.graphicsFPS
		);
	},
	change : function(){
		var form = document.getElementById("controls");
		form.find = function(field){
			return Number(this.elements[field].value);
		};
		this.physics.params.physicsFPS = 1000 / form.find("physics");
		this.physics.params.graphicsFPS = 1000 / form.find("graphics");
		this.physics.params.deltaTime = form.find("simSpeed") / form.find("physics");
		this.physics.params.graphics = form.find("graphics");
		this.physics.params.view = form.elements.view.options[form.elements.view.selectedIndex].value;
		this.pause();
		this.unpause();
	},
	pause : function(){
		clearInterval(graphicsLoopID);
		clearInterval(physicsLoopID);
	},
	unpause : function(){
		physicsLoopID = setInterval(
			function(){
				simulator.physicsLoop();
			},this.physics.params.physicsFPS
		);
		graphicsLoopID = setInterval(
			function(){
				simulator.graphicsLoop();
			},this.physics.params.graphicsFPS
		);
	},
	offsetX : 0,
	offsetY : 0,
	keypress : function(e){
		var evtobj = window.event? event : e;
		var unicode = evtobj.charCode? evtobj.charCode : evtobj.keyCode;
		if(unicode == 97){
			simulator.offsetX -= 10;
		}
		else if(unicode == 100){
			simulator.offsetX += 10;
		}
		else if(unicode == 115){
			simulator.offsetY += 10;
		}
		else if(unicode == 119){
			simulator.offsetY -= 10;
		}
		else if(unicode == 43){
			simulator.mPerPx *= 0.5;
		}
		else if(unicode == 45){
			simulator.mPerPx *= 2;
		};
	}
};
simulator.init();
document.onkeypress = simulator.keypress;
		</script>
